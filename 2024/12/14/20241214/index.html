<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第3章 进程之间的并发控制和死锁 | SEER's Study</title><meta name="author" content="SEER"><meta name="copyright" content="SEER"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="window.MathJax &#x3D; {     tex: {       inlineMath: [[&#39;$&#39;, &#39;$&#39;], [&#39;\\(&#39;, &#39;\\)&#39;]],         displayMath: [[&#39;$$&#39;, &#39;$$&#39;], [&#39;\\[&#39;, &#39;\\]&#39;]]       }   };    1.并发进程的特点-对资源的共享引起的互斥关系：进程之间本来是相互独立的，但由于共享资源而产生了关系。">
<meta property="og:type" content="article">
<meta property="og:title" content="第3章 进程之间的并发控制和死锁">
<meta property="og:url" content="https://seer666.github.io/2024/12/14/20241214/index.html">
<meta property="og:site_name" content="SEER&#39;s Study">
<meta property="og:description" content="window.MathJax &#x3D; {     tex: {       inlineMath: [[&#39;$&#39;, &#39;$&#39;], [&#39;\\(&#39;, &#39;\\)&#39;]],         displayMath: [[&#39;$$&#39;, &#39;$$&#39;], [&#39;\\[&#39;, &#39;\\]&#39;]]       }   };    1.并发进程的特点-对资源的共享引起的互斥关系：进程之间本来是相互独立的，但由于共享资源而产生了关系。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2024-12-14T06:30:00.000Z">
<meta property="article:modified_time" content="2024-12-21T13:35:50.723Z">
<meta property="article:author" content="SEER">
<meta property="article:tag" content="操作系统复习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="https://avatars.githubusercontent.com/u/126209991?v=4"><link rel="canonical" href="https://seer666.github.io/2024/12/14/20241214/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.1.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第3章 进程之间的并发控制和死锁',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-21 21:35:50'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><a href="https://github.com/SEER666" target="_blank"> <img src="https://avatars.githubusercontent.com/u/126209991?v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></a></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://avatars.githubusercontent.com/u/126209991?v=4" alt="Logo"><span class="site-name">SEER's Study</span></a><a class="nav-page-title" href="/"><span class="site-name">第3章 进程之间的并发控制和死锁</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我们</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">第3章 进程之间的并发控制和死锁</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-14T06:30:00.000Z" title="发表于 2024-12-14 14:30:00">2024-12-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-21T13:35:50.723Z" title="更新于 2024-12-21 21:35:50">2024-12-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],  
      displayMath: [['$$', '$$'], ['\\[', '\\]']]  
    }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<h2 id="1-并发进程的特点"><a href="#1-并发进程的特点" class="headerlink" title="1.并发进程的特点"></a>1.并发进程的特点</h2><p>-对资源的共享引起的互斥关系：进程之间本来是相互独立的，但由于共享资源而产生了关系。<br>-协作完成同一个任务引起的同步关系：一组协作进程要在某些同步点上相互等待发信息后才能继续运行。<br>-进程之间的前序关系：由于进程之间的互斥同步关系，使得进程之间具有了前序关系，这些关系决定了各个进程创建和终止的时间。</p>
<p>-<strong>进程之间的关系</strong><br>顺序关系、并行关系、一般关系</p>
<h2 id="2-进程之间的低级通信"><a href="#2-进程之间的低级通信" class="headerlink" title="2.进程之间的低级通信"></a>2.进程之间的低级通信</h2><p>-进程间的低级通信：通过信号量实现进程之间的互斥和同步关系<br>-进程间通信问题——IPC问题</p>
<h3 id="2-1-进程之间的互斥"><a href="#2-1-进程之间的互斥" class="headerlink" title="2.1 进程之间的互斥"></a>2.1 进程之间的互斥</h3><p>共享资源、临界资源【⼀次仅允许⼀个进程使⽤的系统中共享资源】、临界区【并发进程访问临界资源的那段必须互斥执⾏的程序】<br>-<strong>并发进程进入临界区需要遵循的四个准则</strong><br><strong>互斥使⽤；让权等待；有空让进；有限等待</strong><br>-<strong>解决进程之间互斥的方法</strong><br>软件实现方法：共享变量<br>硬件实现方法：关中断【最简单的⽅法。在进程刚进⼊临界区时，⽴即禁⽌所有中断；在进程要<br>离开之前再打开中断】、test&amp;set硬件指令<br>-<strong>使用测试和设置硬件指令</strong><br>所谓变量W：为每个临界资源设置⼀个，以指示其当前状态。W&#x3D;0，表示资源空闲可⽤；W&#x3D;1，表示资源已被占⽤<br>-<strong>加锁方法</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> Const intn=<span class="comment">/*进程数 */</span></span><br><span class="line"> <span class="type">int</span> w;</span><br><span class="line"> <span class="type">void</span> <span class="title function_">p</span><span class="params">(inti)</span>&#123;</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"> <span class="keyword">while</span>(test&amp;<span class="built_in">set</span>(w));<span class="comment">//加锁</span></span><br><span class="line">&lt;criticalsection&gt;</span><br><span class="line"> w=<span class="number">0</span>; <span class="comment">//开锁</span></span><br><span class="line">&lt;remaindersection&gt;</span><br><span class="line"> &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-进程之间的同步"><a href="#2-2-进程之间的同步" class="headerlink" title="2.2 进程之间的同步"></a>2.2 进程之间的同步</h3><p>同步的原因：一组进程要合作完成一项任务</p>
<h3 id="2-3-信号量和P、V操作"><a href="#2-3-信号量和P、V操作" class="headerlink" title="2.3 信号量和P、V操作"></a>2.3 信号量和P、V操作</h3><p>基本原理：两个或多个进程通过简单的信号进⾏合作，⼀个进程被迫在某⼀位置停⽌，直到它接收到另⼀个进程发来的信号。为了发信号，需要使⽤⼀个称作信号量的特殊变量。<br>-对信号量S的操作只允许执⾏P、V原语操作；<br><strong>P操作原语：</strong> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//wait(s) ;</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">P</span> <span class="params">(sem &amp;s)</span></span><br><span class="line"> &#123; s.value = s.value<span class="number">-1</span>; <span class="comment">//表示申请⼀个资源（或通过信号量s等消息）</span></span><br><span class="line"><span class="keyword">if</span> (s.value &lt; <span class="number">0</span>)</span><br><span class="line"> &#123; add this process to s.<span class="built_in">list</span>;</span><br><span class="line"> block( );</span><br><span class="line"> &#125; <span class="comment">//资源⽤完，调⽤阻塞原语。“让权等待”</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>V操作原语：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// signal(s);</span></span><br><span class="line"> Void <span class="title function_">V</span> <span class="params">(sem &amp;s)</span> &#123;</span><br><span class="line"> s.value = s.value+<span class="number">1</span>;</span><br><span class="line"> <span class="comment">//释放⼀个资源（或通过信号量s发消息） </span></span><br><span class="line"><span class="keyword">if</span> (s.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"> remove a process P from s.<span class="built_in">list</span>;</span><br><span class="line"> wakeup( );</span><br><span class="line"> &#125;<span class="comment">//表示在信号链表中，仍有等待该资源的进程被阻塞。 调⽤唤醒原语。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，P、V操作的引⼊，克服了加锁test&amp;set(w)操作的忙等现象，提⾼了系统的效率。<br>阻塞，唤醒<br>-根据⽤途不同，可以把信号量分为公⽤信号量和私⽤信号量。<br>-<strong>公⽤信号量（互斥信号量）</strong>⽤于解决进程之间互斥进⼊临界区。<br>-<strong>私⽤信号量（同步信号量）</strong>⽤于解决某⼏个进程之间的同步。</p>
<p><strong>利用信号量实现进程之间的互斥</strong><br>设置⼀个互斥信号量mutex，初值为1，表示该临界资源空闲。<br>调⽤P(mutex)申请临界资源。<br>调⽤V(mutex)释放临界资源。<br>只需把临界区代码置于P(mutex)和 V(mutex)之间，就可实现临界资源的互斥使⽤了。</p>
<p><strong>操作系统的定义</strong><br>⽤信号量可以⽅便地解决n个进程互斥地执⾏临界区代码的问题。<br>信号量的取值范围：+1～ -(n-1)。<br>信号量值为负时，说明有⼀个进程正在临界区执⾏，其它的正排在信号量等待队列中等待，等待的进程数等于信号量值的绝对值。</p>
<p><strong>生产者和消费者问题</strong><br>-⽣产者和消费者是相互合作进程关系的⼀种抽象<br>⽣产者：当进程释放⼀个资源时，可把它看成是该资源的⽣产者；<br>消费者：当进程申请使⽤⼀个资源时，可把它看成该资源的消费者。</p>
<p>定义：<br>empty：表示空缓冲区的个数，初值为k；<br>full：有数据的缓冲区个数，初值为0；<br>mutex：互斥访问临界区的信号量，初值为1。</p>
<p>int  mutex&#x3D;1, empty&#x3D;k, full&#x3D;0,  i&#x3D;0, j&#x3D;0;<br>int  array[k], x, y;<br>-⽣产者进程（Producer）：<br>…<br>produce a product x;<br>P(empty);    &#x2F;&#x2F;申请⼀个空缓冲<br>P(mutex);    &#x2F;&#x2F;申请进⼊缓冲区<br>array[i] &#x3D; x;      &#x2F;&#x2F;放产品<br>i &#x3D; (i+1)mod k;     &#x2F;&#x2F;修改写指针<br>V(full);    &#x2F;&#x2F;有数据的缓冲区个数加1<br>V(mutex);     &#x2F;&#x2F;退出缓冲区<br>…<br>-消费者进程（Consumer）：<br>…<br>P(full);     &#x2F;&#x2F;申请⼀个产品<br>P(mutex);      &#x2F;&#x2F;申请进⼊缓冲区<br>y &#x3D; array[j];     &#x2F;&#x2F;取产品<br>j &#x3D; (j+1)mod k;    &#x2F;&#x2F;修改读指针<br>V(empty);    &#x2F;&#x2F;释放1个空缓冲<br>V(mutex);    &#x2F;&#x2F;退出缓冲区<br>…</p>
<p><strong>注意P操作的次序</strong><br>若⽣产者进程中的两个P操作的次序交换：<br>当缓冲区满时，⽣成者将在P(empty)上等待，但不释放对缓冲区的互斥使⽤权；<br>此后，消费者欲取产品时，由于申请使⽤缓冲区不成功，它将在P(mutex)上等待；<br>相互等待就会造成系统发⽣死锁现象。</p>
<p><strong>读者和写者问题</strong><br>读&#x2F;写问题：<br>有⼀个多进程共享的数据区，这个数据区可以是⼀个⽂件或者主存的⼀块空间。有⼀些只读取这个数据区的读进程（reader)和⼀些只往<br>数据区中写数据的写进程（writer)。此外还必须满⾜以下条件：<br>多个读进程可以同时读这个数据区；<br>⼀次只有⼀个写进程可以往数据区中写；<br>若⼀个写进程正在写，禁⽌任何进程读。<br>信号量的设置：<br>写互斥信号量wmutex：<br>实现读写互斥和写写互斥地访问共享⽂件，初值为1。<br>计数器readcount：<br>记录同时读的读者数，初值为0。<br>读互斥信号量rmutex：<br>使读者互斥地访问计数器readcount，初值为1。<br>int wmutex&#x3D;1, readcount&#x3D;0, rmutex&#x3D;1;<br>Reader:<br>P(rmutex);      &#x2F;&#x2F;互斥访问<br>readcount<br>if readcount&#x3D;&#x3D;0 then P(wmutex);<br> readcount++;<br>V(rmutex);<br>读⽂件;<br>P(rmutex);<br> readcount&#x3D; readcount-1;<br>if readcount&#x3D;&#x3D;0 then V(wmutex);<br> V(rmutex);<br>Writer： …<br> P(wmutex);<br> 写⽂件;<br> V(wmutex)；<br> …</p>
<p><strong>理发师问题</strong><br>⼀个理发师和n把空椅⼦。如果没有顾客，则理发师坐在椅⼦上睡觉，当有⼀个顾客到来时，就唤醒理发师，请求理发；如果理发师正在理发，⼜有顾客到来时，只要有空椅⼦，他就坐下来等待理发。请为理发师和顾客各编写⼀段程序来描述他们的同步问题。</p>
<p>设两个同步信号量：<br>⽤s1制约理发师，初值为0，表示有0个顾客；<br>⽤s2制约顾客，表示空椅⼦数，初值为n。<br>理发师：<br>P(s1);      &#x2F;&#x2F;等顾客<br>给顾客理发； V(s1);     &#x2F;&#x2F;增加顾客数<br>V(s2);     &#x2F;&#x2F;释放椅⼦<br>顾客：<br>P(s2);     &#x2F;&#x2F;申请椅⼦<br>V(s1);     &#x2F;&#x2F;增加顾客数<br>坐椅⼦上等理发；</p>
<p><strong>哲学家进餐问题</strong><br>典型的同步问题，是⼀⼤类并发控制问题的例⼦<br>假设有5个哲学家，花费⼀⽣的时光思考和吃饭。<br>在桌⼦上放着5⽀筷⼦；<br>⼀个哲学家要分两次去取其左边和右边的筷⼦；<br>若得到两⽀筷⼦，就开始吃饭；<br>吃完放下两⽀筷⼦。</p>
<p>int fork[0]&#x3D;fork[1]&#x3D;…&#x3D;fork[4]&#x3D;1;   &#x2F;&#x2F;五个互斥信号量<br>第i个哲学家所执⾏的程序：<br>do{<br>P(mutex);<br> P(fork[i]);<br> P(fork[(i+1)mod5]);<br> V(mutex);<br>吃饭<br>V(fork[i]);<br> V(fork[(i+1)mod5]);<br> } while(1)；</p>
<h2 id="3-管程"><a href="#3-管程" class="headerlink" title="3.管程"></a>3.管程</h2><p><strong>管程</strong>是关于共享资源的数据结果及一组针对该资源的操作过程所构成的软件模块。<br><strong>管程保证</strong>：一次只有一个进程执行管程中的代码。从而提供互斥机制，保证管程数据的一致性。</p>
<p>-管程的组成：<br>Monitor  monitor-name {<br>……              &#x2F;&#x2F;局部于该管程的共享变量的说明<br>condition ……    &#x2F;&#x2F;条件变量<br>define ……;      &#x2F;&#x2F;本管程内定义的过程名<br>use ……;         &#x2F;&#x2F;操作条件变量的同步原语<br>……              &#x2F;&#x2F;本管程内定义的各过程（函数体）<br>}</p>
<p>-用管程解决临界资源的互斥适用<br>Monitor  mutexshow {<br>boolean busy&#x3D;false; &#x2F;&#x2F;临界资源是否可⽤标志<br>condition nonbusy; &#x2F;&#x2F;等待队列的条件变量<br>definerequest, release; &#x2F;&#x2F;管程中的过程说明<br>use wait, signal;  &#x2F;&#x2F;引⽤外部模块<br>}<br>调⽤wait()的进程会阻塞在条件变量nonbusy的等待队列上；<br>调⽤signal()会唤醒⼀个阻塞进程，若⽆阻塞进程则signal()不起作⽤。</p>
<p><strong>局限性</strong><br>管程是编程语言的组成部分，编译器知道它们的特殊性，因此对其操作做出互斥安排。</p>
<h2 id="4-进程的高级通信"><a href="#4-进程的高级通信" class="headerlink" title="4.进程的高级通信"></a>4.进程的高级通信</h2><p>低级通信的缺点：P、V操作的适用增加了程序的复杂性；<br>P、V操作使用不当，易导致死锁；<br>当程序非正常撤离时，查找只做了P操作而未做V操作的程是很困难的。<br>-高级通信：<br> -是指进程采用操作系统提供的多种通信方式来实现通信；<br> -如消息缓冲、信箱、管道、共享主存区等。<br>-发送进程和接收进程的消息通信方式：<br> -阻塞发送：发送进程阻塞，直到消息被接收<br> -非阻塞发送：发送消息并继续运行<br> -阻塞接收：接收进程阻塞，直到有消息可用<br> -非阻塞接收：收到一个有效消息或空消息</p>
<h3 id="4-1-消息缓冲通信"><a href="#4-1-消息缓冲通信" class="headerlink" title="4.1 消息缓冲通信"></a>4.1 消息缓冲通信</h3><p>-实现方法：<br> -系统设置一个消息缓冲池，其中每个缓冲区可以存放一个消息；<br> -每当进程欲发送消息时，向系统申请一个缓冲区，将消息存入缓冲区，然后把该缓冲区链接到接收进程的消息队列上；<br> -消息队列通常放在接收进程的进程控制块中；<br> -属于直接通信方式。<br><strong>（1）消息缓冲区的类型</strong><br>struct  message_buffer{<br>xx sender;    &#x2F;&#x2F;发送进程标识符<br>xx size;      &#x2F;&#x2F;消息长度<br>xx text;      &#x2F;&#x2F;消息正文<br>struct message_buffer *next;      &#x2F;&#x2F;指向下一个消息缓冲区的指针<br>}<br><strong>（2）PCB中有关通信的数据项描述</strong><br>struct PCB{<br>…<br>mq;       &#x2F;&#x2F;消息队列队⾸指针<br>mutex;    &#x2F;&#x2F;消息队列互斥信号量<br>sm;       &#x2F;&#x2F;消息队列同步信号量<br>…<br>}<br>消息队列通常放在进程控制块中。<br><strong>（3）发送、接收系统调用</strong><br>send(接收者，被发送消息始址)<br>receive(发送者，接收区始址)<br>-发送者先在⾃⼰的地址空间形成⼀个消息发送区，将消息写⼊其中，然后调⽤发送原语；<br>-发送原语：从系统缓冲区申请⼀个消息缓冲区，将消息从发送区传⼊其中， 然后挂到接收进程的消息队列上；<br>-接收原语：将消息接收到自己的接收区</p>
<p>-<strong>消息缓冲通信</strong>*<br>send(receiver, a){     &#x2F;&#x2F;发送原语<br>getbuf(a.size, i)；    &#x2F;&#x2F;据a区消息⻓度来申请⼀系统缓冲区i<br>i.sender&#x3D;a.sender;<br>i.size&#x3D;a.size;<br>i.text&#x3D;a.text;    i.next&#x3D;0;<br>getid(PCB set, receiver, j);  &#x2F;&#x2F;获得接收进程的内部标识符j<br>P(j.mutex);<br>insert(j.mq, i);    &#x2F;&#x2F;将i挂在接收进程j的消息队列mq上(临界资源）<br>V(j.mutex);<br>V(j.sm);    &#x2F;&#x2F;消息队列同步信号量sm<br>}d</p>
<p>receive(b){  &#x2F;&#x2F;接收原语<br>j&#x3D;get caller’s internal name;  &#x2F;&#x2F;内部标识符<br>P(j.sm);    &#x2F;&#x2F;等消息<br>P(j. mutex);<br> remove(j.mq, i); &#x2F;&#x2F;从⾃⼰的消息缓冲队列mq中摘下第⼀个消息缓冲<br>区i。<br>V(j.mutex);<br> b.sender&#x3D;i.sender;<br> b.size&#x3D;i.size;<br> b.text&#x3D;i.text;<br> }</p>
<p><strong>信箱通信</strong><br>发送进程将消息发送到中间媒介——信箱，接收进程从中去的消息。<br>间接通信方式：<br>-发送原语：send(A,Msg) 将一个消息Msg发送到信箱A<br>-接收原语：receive(A,Msg) 从信箱A中接收一个消息Msg</p>
<p><strong>管道通信</strong><br>是指⽤于连接⼀个读进程和⼀个写进程的共享⽂件，⼜称pipe⽂件。OS强制实施互斥。<br>是通过OS管理的环形缓冲区。先进先出。<br>命令⽅式的管道通信；程序⽅式的管道通信。</p>
<p><strong>共享存储区</strong><br>诸进程为了相互交换⼤量数据，申请创建⼀块共享存储区，并将共享存储区映射到各⾃的地址空间，通过读或写共享存储区中的数据来实现通信。</p>
<h2 id="5-死锁"><a href="#5-死锁" class="headerlink" title="5.死锁"></a>5.死锁</h2><h3 id="5-1-死锁的定义和产生的必要条件"><a href="#5-1-死锁的定义和产生的必要条件" class="headerlink" title="5.1 死锁的定义和产生的必要条件"></a>5.1 死锁的定义和产生的必要条件</h3><p>-资源的特性<br> -可抢占资源：当资源从占⽤进程剥夺⾛时，对进程不产⽣什么破坏性的影响。如主存、CPU<br> -不可抢占资源（临界资源）：⼀旦分配，不能强收回，只能由其⾃动释放。如打印机、磁带机。</p>
<h4 id="5-1-1-死锁的定义"><a href="#5-1-1-死锁的定义" class="headerlink" title="5.1.1 死锁的定义"></a>5.1.1 死锁的定义</h4><p>⼀组进程是死锁的，是指这⼀组中的每个进程都正在等待该组中的其他进程所占⽤资源时，可能引起的⼀种错误现象。</p>
<h4 id="5-1-2-死锁产生的必要条件"><a href="#5-1-2-死锁产生的必要条件" class="headerlink" title="5.1.2 死锁产生的必要条件"></a>5.1.2 死锁产生的必要条件</h4><p>-互斥条件：独占性的资源；<br>-保持和等待条件：进程因请求资源而阻塞时，对已经获得的资源保持不放；<br>-不剥夺条件：已分配给进程的资源不能被剥夺，只能有进程自己释放；<br>-循环等待条件：存在一个进程循环链，链中每个进程都在等待链中的下一个进程所占用的资源。</p>
<h4 id="5-1-3-死锁产生的原因"><a href="#5-1-3-死锁产生的原因" class="headerlink" title="5.1.3 死锁产生的原因"></a>5.1.3 死锁产生的原因</h4><p>-系统资源配置不⾜，引起进程竞争资源。<br>-并发进程请求资源的随机性，包括所请求资源的类别和数量。<br>-各并发进程在系统中异步向前推进，造成进程推进顺序的不合理性。<br>产⽣死锁的根本原因：是对独占资源的共享，并发进程的同步关系不当。</p>
<h3 id="5-2-解决死锁的方法"><a href="#5-2-解决死锁的方法" class="headerlink" title="5.2 解决死锁的方法"></a>5.2 解决死锁的方法</h3><h4 id="5-2-1-鸵鸟算法"><a href="#5-2-1-鸵鸟算法" class="headerlink" title="5.2.1 鸵鸟算法"></a>5.2.1 鸵鸟算法</h4><p>最简单的解决⽅法是鸵⻦算法：把头埋进沙⼦⾥，假装毫⽆问题。<br>如果死锁平均每5年发⽣⼀次，⽽每个⽉系统都会因硬件故障、编译器错误或者操作系统故障⽽崩溃⼀次，那么⼤多数⼯程师不会花费代价去防⽌系统死锁。</p>
<h4 id="5-2-2-死锁的预防"><a href="#5-2-2-死锁的预防" class="headerlink" title="5.2.2 死锁的预防"></a>5.2.2 死锁的预防</h4><p>因产生死锁需四个必要条件。若能破坏其中的一个或几个条件，则不产生死锁。<br>-破坏互斥条件<br> -资源的互斥使⽤条件是由资源本⾝性质决定的，不能破坏。<br> -如果采⽤spooling技术，借助磁盘空间，就可以将⼀台独享设备改造成多台设备，以满⾜多个进程的共享需求。如打印机。<br> -实际中，不是所有设备都能采⽤spooling技术的。即使采⽤了该技术，由于多个进程竞争磁盘空间，磁盘空间的不⾜，仍可能导致死锁。<br>-破坏保持和请求条件<br> -让进程在开始运行前，就获得所需的全部资源。若系统不能满足，则该进程等待。<br> -属静态分配，资源利用率低。<br> -许多进程在开始运行之前，不能精确提出所用资源数量。<br>-破坏非剥夺条件<br> -当⼀个进程已占有某些资源，⼜申请新的资源⽽得不到满⾜时，则在进⼊阻塞状态前强⾏使其释放已经占有的资源。以后运⾏时，再重新申请。<br> -显然也不⾏，因为保护进程放弃资源时的现场以及之后的恢复现场，系统要付出很⾼的代价。<br>-破坏循环等待条件<br> -将将系统全部资源按类进⾏全局编号排序。进程对资源的请求必须按照资源的序号递增顺序进⾏。这样，就不会出现进程循环等待资源，预防死锁。<br> -但找到能满足所有进程要求的资源编号是不可能的。</p>
<h3 id="5-3-死锁的避免"><a href="#5-3-死锁的避免" class="headerlink" title="5.3 死锁的避免"></a>5.3 死锁的避免</h3><p>基本思想：允许进程动态地申请资源，⼀次申请⼀部分资源。系统在进⾏资源分配之前，先计算资源分配的安全性。若此次分配不会导致系统进⼊不安全状态，便将资源分配给进程；否则，进程等待。</p>
<p><strong>银行家算法</strong><br>-安全状态：是指系统能按某种顺序，来为每个进程分配其所需资源，直⾄最⼤需求，使每个进程都可顺利完成。<br>银行家算法详情可见视频链接<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV17k4y1X7dF?buvid=XXC7599C1F07B1FBC797605D30D55CC57231B&from_spmid=main.my-history.0.0&is_story_h5=false&mid=ORqMdPDy08VKuNsjHF9/zw==&plat_id=116&share_from=ugc&share_medium=android&share_plat=android&share_session_id=52cc0c88-6934-4412-ab2c-82fdd99ac853&share_source=WEIXIN&share_tag=s_i&spmid=united.player-video-detail.0.0&timestamp=1734763760&unique_k=nICFjhL&up_id=1026421414">银行家算法</a></p>
<p>-检查一个状态是否安全：<br> -检查剩余请求矩阵R是否有⼀⾏，其剩余请求向量⼩于等于系统剩余资源向量A。若不存在这样的⾏系统将会死锁。<br> -若找到这样⼀⾏，则可以假设它获得所需的资源并运⾏结束，并将其占⽤资源归还系统。<br> -重复以上两步，直到所有进程都标记为终⽌；或者直到死锁发⽣，出现不安全状态。</p>
<h3 id="5-4-死锁的检测和恢复"><a href="#5-4-死锁的检测和恢复" class="headerlink" title="5.4 死锁的检测和恢复"></a>5.4 死锁的检测和恢复</h3><p>-死锁的检测和恢复技术：<br> -死锁的检测和恢复技术：<br>  -是指定期启动一个软件检测系统的状态，若发现有死锁存在，则采取措施恢复之。<br> -死锁的检测——用进程资源图检测死锁<br>  -检查由进程和资源构成的有向图是否包含一个或多个环路，若是，则存在死锁，否则不存在。<br>  资源图格式如图：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1ihYtJQb20eMJE6Q042EPMA">进程资源图规范,提取码6wgy</a>   </p>
<p><strong>死锁的恢复</strong><br>-故障终止一些进程<br> -故障终止所有死锁进程——简单。<br> -一次终止一个死锁进程，直到死锁解除为止。<br>-资源剥夺<br> -夺⾛⼀个进程的资源，给另⼀个进程使⽤。<br> -将⼀死锁进程滚回到获得资源之前的执⾏点。为进程设置执⾏点是指将进程在该点的执⾏状态信息到⼀个⽂件中，便于以后从该执⾏点启动进程执⾏。</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p><strong>1.程序顺序执行的特点。</strong><br>一次只运行一道程序。具有封闭性、可再现性的特点。<br>-封闭性：程序在运⾏时独占全机资源，因此，这些资源的状态只由⼀个程序决定和改变，不受外界因素影响。<br>-可再现性：只要初始条件相同，⽆论程序连续运⾏，还是断断续续地运⾏，程序的执⾏结果不变。</p>
<p><strong>2.何谓进程，进程由哪些部分组成？试述进程的四大特性（动态性、独立性、并发性、结构性）及程和程序的区别。</strong><br>-进程：又叫任务，是程序的一次执行过程，程序在一个数据集合上顺序执行时发生的活动。<br>-动态性：进程是程序的一次执行过程，是临时的，有生命期的。<br>-独立性：进程是系统进⾏资源分配和调度的⼀个独⽴单位。<br>-并发性：多个进程可在处理机上交替执⾏。<br>-结构性：系统为每个进程建⽴⼀个进程控制块。<br>-进程和程序的区别：<br> -进程是动态的，程序是静态的。<br> -进程是暂时的，程序是永久的。<br> -进程包括程序、数据和进程控制块。<br> -通过多次执⾏，⼀个程序可对应多个进程；通过调⽤关系，⼀个进程可包括多个程序。进程可创建其他进程，⽽程序不能形成新的程序。</p>
<p><strong>3.进程控制块的作用是什么?它主要包括哪几部分内容?</strong><br>-PCB是进程存在的唯一标识，通常，一个进程的信息包括：<br> -一个可执行程序(**.exe)<br> -一个度里的地址空间<br> -一个执行栈区（子程序调用，系统调用，进程切换）<br> -打开的文件、申请使用的I&#x2F;O设备等<br>-包括如下内容：<br> -进程标识数: 用于唯一地标识一个进程，通常是一个整数。外部标识符，由用户使用。如：send进程，print进程等。<br> -进程的状态、调度、存储器管理信息: 调度进程所必需的信息，包括进程状态、优先级、程序在存住地址、在外存的地址等。<br> -进程使用的资源信息: 分配给进程的I&#x2F;O设备、正在打开的文件等。 [ ] CPU现场保护信息: 保存进程运行的现场信息。包括: 程序计数器(PC)、程序状态字、通用寄存器、堆栈指针等。<br> -记账信息: 包括使用CPU时间、帐务等。<br> -进程之间的家族关系: 类Unix系统，进程之间存在着家族关系、父&#x2F;子进程。Windows进程之间不具有父子关系。<br> -进程间链接指针: 链接相同状态的进程。</p>
<p><strong>4.进程的基本状态，试举出使进程状态发生变化的事件并描绘它的状态转换图。</strong><br>-运行态(running): 进程正在CPU上运行。单CPU系统一次只有一个运行进程; 多CPU系统可能有多个运行进程。<br>-阻塞态(blocked): 又称等待态。当进程因等待某个事件发生而不能运行时所处的状态。等待I&#x2F;O完成，等待一个消息。<br>-就绪态(ready): 已获得除CPU之外的全部资源，只要再获得CPU，就可执行。<br>-创建态: 刚刚建立，未进入就绪队列。<br>-终止态: 已正常结束或故障中断，但尚未撤销。暂留在系统中，方便其后进程去收集该进程的有关信息。</p>
<p><strong>5.什么是原语?什么是进程控制?</strong><br>-原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断。<br>-进程控制是指系统使用一些具有特定功能的程序段来创建、撤销进程，以及完成进程各状态之间的转换。</p>
<p><strong>6.进程调度的功能、方式、时机、算法。作业调度、交换调度。作业的周转时间和作业的带权周转时间?</strong><br>-功能：<br> -管理系统中各进程的执行状况<br> -选择就绪进程占有CPU<br> -进行进程上下文的切换<br>-方式：<br> -非抢先方式(非剥夺方式)<br> -抢先方式(剥夺方式)<br>-时机：<br> -进程完成或错误终止；<br> -提出I&#x2F;O请求，等待I&#x2F;O完成时；<br> -在分时系统，按照时间片轮转，分给进程的时间片用完时；<br> -优先级调度，有更高优先级进程就绪；<br> -进程执行了某种原语操作，如阻塞原语和唤醒原语，都可能引起进程调度。<br>-调度算法：<br> -先来先服务(FCFS)<br> -最短作业优先(SJF)<br> -响应比高者优先(HRN)<br> -优先级调度法(priority scheduling)<br> -轮转法(Round Robin)<br> -多级反馈队列轮转法(Round Robin with Multiple Feedback)<br>-作业调度： 高级调度。多道批处理系统。多个用户作业提交到外存，形成后备作业队列。被作业调度选中进内存，就处于运行态。<br>-交换调度: 中级调度。将主存中暂不具备运行条件的进程换出到外存交换区；或将外存交换区中的已具备运行条件的进程换入主存。<br>-进程调度: 低级调度。为进程分配处理机。<br>-指从作业进入系统到作业退出系统所用的时间。(等待时间+运行时间)<br>-带权周转时间是指作业的周转时间与系统为它提供服务的时间之比。</p>
<p><strong>7.线程的定义，线程与进程的比较。系统对线程的支持（用户级线程、核心级线程、两级组合）。</strong><br>-线程是操作系统能够调度运行的最小单位，是包含在进程中的一个单一顺序的控制流。<br>-线程与进程的比较<br> -拥有的资源：<br>  -进程拥有一个独立的地址空间，用来存放若干代码段和数据段。拥有打开的文件，以及至少一个线程。<br>  -一个进程内的多个线程共享该进程的所有资源，线程自己拥有很少资源。<br> -调度<br>  -进程调度需进行进程上下文的切换，开销大。<br>  -同一进程内的线程切换，仅把线程拥有的小部分资源变换即可，效率高。同一进程内的线程切换比进程切换快得多。不同进程的线程切换…<br> -并发性<br>  -引入线程后，使得系统的并发执行程度更高。进程之间，进程内的多线程之间可并发执行。<br> -安全性<br>  -同一进程的多线程共享进程的所有资源，一个线程可以改写另一个线程的数据，共享数据方便。多线程实现安全性好。</p>
<p>-系统对线程的支持<br>-用户级线程<br> -有关线程的所有管理工作都由用户程序通过调用在用户态运行的线程库完成。系统内核并不知道线程的存在。<br>  -系统内核以进程为单位进行调度。一个线程阻塞，其依附的进程也阻塞。<br>  -多线程对应核心一级一个进程。<br>  -如，POSIX的Pthread线程库。<br>-核心级线程<br> -有关线程的管理工作都由内核完成。应用程序通过系统调用来创建或撤销线程。<br> -一个线程的阻塞，不影响其他线程的执行。<br> -Windows、Linux多处理机系统。<br>-两级组合<br> -既支持用户级线程，也支持核心级线程。<br> -用户级多个线程对应核心级多个线程。<br> -当内核了解到一个线程阻塞后，通知运行时系统，重新调度其他线程。</p>
<p><strong>8.并发执行的进程在系统中通常表现为几种关系?各是在什么情况下发生的?</strong><br>-对资源的共享引起的互斥关系:<br> -进程之间本来是相互独立的，但由于共享资源而产生了关系。间接制约关系，互斥关系。<br>-协作完成同一个任务引起的同步关系：<br> -一组协作进程要在某些同步点上相互等待发信息后才能继续运行。直接制约关系，同步关系。<br>-进程之间的前序关系：<br> -由于进程之间的互斥同步关系，使得进程之间具有了前序关系，这些关系决定了各个进程创建和终止的时间。</p>
<p><strong>9.什么叫临界资源?什么叫临界区?对临界区的使用应符合的四个准则。</strong><br>-临界资源：一次仅允许一个进程使用的系统中共享资源。<br>-临界区：并发进程访问临界资源的那段必须互斥执行的程序。<br>-四个准则：<br> -不能同时有两个进程在临界区内执行；<br> -等待进入临界区的进程，应释放处理机后阻塞等待；<br> -在临界区外运行的进程不应阻止其他进程进入临界区；<br> -不应使要进入临界区的进程无限期等待在临界区之外。</p>
<p><strong>10.解决进程之间互斥的办法：硬件方法，软件方法。</strong><br>-硬件实现方法：关中断、test&amp;set硬件指令<br> -关中断：在进程刚进⼊临界区时，⽴即禁⽌所有中断；在进程要离开之前再打开中断。<br> -test&amp;set硬件指令测试（读取）锁位变量的值。<br>-软件实现方法：共享变量</p>
<p>**11.若信号量S表示某一类资源，则对S执行P、V操作的直观含意是什么? 当进程对信号量S执行P、V操作时，S的值发生变化，当S&gt;0、S&#x3D;0、和S&lt;0时，其物理意义是什么?**<br>-P 操作：<br> -直观含义：请求一个资源。<br> -实际操作：将 S 的值减 1。<br> -如果 S 的新值为负，则表示没有可用的资源，进程需要阻塞等待资源可用。<br>-V 操作 (Verhogen 或 Signal)：<br> -直观含义：释放一个资源。<br> -实际操作：将 S 的值加 1。<br> -如果 S 的新值不再是负数，则表示有进程可以从阻塞队列中唤醒，因为有资源可用了。<br>-信号量 S 的值及其物理意义：<br> -当 S &gt; 0：表示有 S 个资源可用，任意进程可以执行 P 操作并获得资源而无需等待。<br> -当 S &#x3D; 0：表示没有可用资源，如有进程要执行 P 操作，则必须等待，表示资源完全被占用。<br> -当 S &lt; 0：表示有 |S| 个进程在等待资源。每一个负值代表一个因为没有资源而被阻塞的进程。例如，S &#x3D; -3 表示有 3 个进程在等待资源。</p>
<p><strong>12.在用P&#x2F;V操作实现进程通信时，应根据什么原则对信号量赋初值？</strong><br>-资源计数<br> -写互斥信号量wmutex：<br>  -实现读写互斥和写写互斥地访问共享⽂件，初值为1。<br> -计数器readcount：<br>  -记录同时读的读者数，初值为0。<br> -读互斥信号量rmutex：<br>  -使读者互斥地访问计数器readcount，初值为1。</p>
<p>-进程同步<br> -同步信号量：⽤于解决某⼏个进程之间的同步。初值可以为0，执行后为1.</p>
<p>-生产者-消费者问题<br> -空缓冲区计数信号量：初值设为缓冲区的总数量，表示所有缓冲区最初都是空的。<br> -满缓冲区计数信号量：初值设为 0，表示最初没有产品。<br> -互斥信号量：用于保护对缓冲区的访问，初值设为 1。</p>
<p><strong>13.经典的IPC问题。</strong><br>生产者-消费者问题：<br>-⽣产者和消费者是相互合作进程关系的⼀种抽象<br> -⽣产者：当进程释放⼀个资源时，可把它看成是该资源的⽣产者；<br> -消费者：当进程申请使⽤⼀个资源时，可把它看成该资源的消费者。<br>-解决方案：<br> 使用两个计数信号量 Empty 和 Full 分别表示空缓冲区和满缓冲区的数量，另一个互斥信号量 Mutex 保护缓冲区的访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Semaphore Empty = N; // 缓冲区大小</span><br><span class="line">Semaphore Full = 0;</span><br><span class="line">Semaphore Mutex = 1; // 互斥信号量</span><br><span class="line"></span><br><span class="line">Producer:</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    produceItem(); // 生成一个新产品</span><br><span class="line">    P(Empty);      // 等待有空的缓冲区</span><br><span class="line">    P(Mutex);      // 进入临界区</span><br><span class="line">    putItemInBuffer(); // 将产品放入缓冲区</span><br><span class="line">    V(Mutex);      // 离开临界区</span><br><span class="line">    V(Full);       // 增加满缓冲区计数</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">Consumer:</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    P(Full);       // 等待有满的缓冲区</span><br><span class="line">    P(Mutex);      // 进入临界区</span><br><span class="line">    removeItemFromBuffer(); // 从缓冲区取出产品</span><br><span class="line">    V(Mutex);      // 离开临界区</span><br><span class="line">    V(Empty);      // 增加空缓冲区计数</span><br><span class="line">    consumeItem(); // 消费产品</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>哲学家就餐问题:<br>-问题描述：<br>五个哲学家围坐在圆桌，每个哲学家有一只叉子，每个哲学家必须同时拥有左右两只叉子才能进餐。需要防止死锁和饥饿。<br>-解决方案：<br>使用一个互斥信号量 Mutex 来保护对叉子的获取，另有一个信号量数组 Chopstick。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Semaphore Mutex = 1; // 保护对叉子的访问</span><br><span class="line">Semaphore Chopstick[5] = &#123;1, 1, 1, 1, 1&#125;;</span><br><span class="line"></span><br><span class="line">Philosopher(i):</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    think();          // 哲学家思考</span><br><span class="line">    P(Mutex);         // 进入临界区</span><br><span class="line">    P(Chopstick[i]);  // 拿起左边的叉子</span><br><span class="line">    P(Chopstick[(i+1) % 5]); // 拿起右边的叉子</span><br><span class="line">    V(Mutex);         // 离开临界区</span><br><span class="line">    eat();            // 哲学家进餐</span><br><span class="line">    V(Chopstick[i]);  // 放下左边的叉子</span><br><span class="line">    V(Chopstick[(i+1) % 5]); // 放下右边的叉子</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>读者-写者问题<br>-问题描述：<br>多个读者可同时读取共享资源，但写者在写入时不得有其他读者或写者访问共享资源。<br>-解决方案：<br>使用计数信号量 Mutex 和 Wr，以及读者计数器 ReadCount。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Semaphore Mutex = 1; // 保护对 ReadCount 的访问</span><br><span class="line">Semaphore Wr = 1;    // 保护对共享资源的访问</span><br><span class="line">int ReadCount = 0;</span><br><span class="line"></span><br><span class="line">Reader:</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    P(Mutex); </span><br><span class="line">    ReadCount++;</span><br><span class="line">    if (ReadCount == 1) P(Wr); // 第一个读者阻止写者</span><br><span class="line">    V(Mutex); </span><br><span class="line">    read(); // 读取共享资源</span><br><span class="line">    P(Mutex); </span><br><span class="line">    ReadCount--;</span><br><span class="line">    if (ReadCount == 0) V(Wr); // 最后一个读者释放写者</span><br><span class="line">    V(Mutex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">Writer:</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    P(Wr); </span><br><span class="line">    write(); // 写入共享资源</span><br><span class="line">    V(Wr);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>14.进程高级通信有哪些实现机制？</strong><br>-消息缓冲通信<br> -系统设置⼀个消息缓冲池，其中每个缓冲区可以存放⼀个消息<br> -每当进程欲发送消息时，向系统申请⼀个缓冲区，将消息存⼊缓冲区，<br> -然后把该缓冲区链接到接收进程的消息队列上<br> -消息队列通常放在接收进程的进程控制块中<br> -属于直接通信⽅式<br>-信箱通信<br> -发送进程将消息发送到中间媒介—信箱，接收进程从中取得消息。<br>-管道通信<br> -是指⽤于连接⼀个读进程和⼀个写进程的共享⽂件，⼜称pipe⽂件。OS强制实施互斥。<br> -是通过OS管理的环形缓冲区。先进先出。<br> -命令⽅式的管道通信；程序⽅式的管道通信。<br>-共享存储区<br> -诸进程为了相互交换⼤量数据，申请创建⼀块共享存储区，并将共享存储区映射到各⾃的地址空间，通过读或写共享存储区中的数据来实现通信。</p>
<p><strong>15.死锁产生的必要条件及解决死锁的方法</strong><br>-死锁产生的必要条件：<br> -互斥条件：独占性的资源<br> -保持和等待条件：进程因请求资源⽽阻塞时，对已经获得的资源保持不放<br> -不剥夺条件：已分配给进程的资源不能被剥夺，只能由进程⾃⼰释放<br> -循环等待条件：存在⼀个进程循环链，链中每个进程都在等待链中的下⼀个进程所占⽤的资源<br>-解决死锁的方法：<br> -鸵⻦算法：忽略死锁<br> -死锁的预防：通过破坏产⽣死锁的四个必要条件中的⼀个或⼏个，来防⽌发⽣死锁<br> -死锁的避免：是在资源的动态分配过程中，⽤某种⽅法去防⽌系统进⼊不安全状态，从⽽避免发⽣死锁<br> -死锁的检测和恢复<br> -允许死锁发⽣。通过设置检测机构，及时检测出死锁的发⽣，然后采取适当措施清除死锁</p>
<p><strong>16.理解银行家算法的实质。能够利用银行家算法避免死锁。</strong><br>-银行家算法的关键概念<br> -安全状态：如果系统存在某个安全序列，使得所有的进程可以顺序地完成其执行而不发生死锁，则该状态为安全状态。<br> -不安全状态：如果不存在这样的安全序列，则该状态为不安全状态。不安全状态并不一定会导致死锁，但有可能演变为死锁。<br>-数据结构<br> -Available：长度为 m 的数组，表示每种资源类型当前剩余的可用资源数量。<br> -Max：n x m 的矩阵，表示每个进程对每一种资源的最大需求量。<br> -Allocation：n x m 的矩阵，表示当前已经分配给每个进程的各类资源数量。<br> -Need：n x m 的矩阵，表示每个进程还需要的资源数量，计算公式为 Need[i][j] &#x3D; Max[i][j] - Allocation[i][j]。<br>-算法步骤<br>-安全性算法<br> -1.初始化：<br>  -Work &#x3D; Available（系统可供资源数）。<br>  -Finish[i] &#x3D; false（初始化表示所有进程都未完成）。<br> -2.查找进程：<br>  -找到一个满足下述条件的进程 P_i：Finish[i] &#x3D;&#x3D; false 且 Need[i] &lt;&#x3D; Work。如果找到这样的进程，执行以下步骤，否则转到步骤 4。<br> -3.假设分配：<br>  -Work +&#x3D; Allocation[i]（假设 P_i 请求了其需求的所有资源并完成）。<br>  -Finish[i] &#x3D; true。<br>  -返回步骤 2。<br> -4.判断安全性：<br>  -如果所有的 Finish[i] &#x3D; true，则系统处于安全状态；否则，系统处于不安全状态。<br>-请求资源算法<br> -请求合法性检查：<br>  -如果 Request[i] &gt; Need[i]，则为非法请求，拒绝。<br>  -如果 Request[i] &gt; Available，则需阻塞进程 P_i。<br> -预分配资源：<br>  -临时分配资源：Available -&#x3D; Request[i]；Allocation[i] +&#x3D; Request[i]；Need[i] -&#x3D; Request[i]。<br> -安全性检查：<br>  -使用安全性算法判断预分配后的状态。如果是安全状态，则正式分配资源；否则，恢复先前状态（即回滚预分配），进程 P_i 继续等待。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://SEER666.github.io">SEER</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://seer666.github.io/2024/12/14/20241214/">https://seer666.github.io/2024/12/14/20241214/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://SEER666.github.io" target="_blank">SEER's Study</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/">操作系统复习</a></div><div class="post-share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2024/12/12/20241212/" title="第2章 进程管理"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">第2章 进程管理</div></div><div class="info-2"><div class="info-item-1">   window.MathJax = {     tex: {       inlineMath: [['$', '$'], ['\\(', '\\)']],         displayMath: [['$$', '$$'], ['\\[', '\\]']]       }   };    1.进程的描述：PCB、状态2....</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/12/10/20241210/" title="第1章 操作系统概论"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-10</div><div class="info-item-2">第1章 操作系统概论</div></div><div class="info-2"><div class="info-item-1">   window.MathJax = {     tex: {       inlineMath: [['$', '$'], ['\\(', '\\)']],         displayMath: [['$$', '$$'], ['\\[', '\\]']]       }   };    1.1 操作系统的定义计算机系统的组成：应用程序 -&gt; 实用程序 -&gt; 操作系统 -&gt; 硬件 接口：外层的软件必须以事先约定的方式，调用内层软件或硬件提供的服务。 操作系统的定义： 是由一系列程序模块组成的一个大型的系统管理程序；依据各种管理和调度策略，对计算机的软、硬件资源进行统一的管理和调度，合理地组织计算机的工作流程，以提高资源利用率。 1.2...</div></div></div></a><a class="pagination-related" href="/2024/12/12/20241212/" title="第2章 进程管理"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-12</div><div class="info-item-2">第2章 进程管理</div></div><div class="info-2"><div class="info-item-1">   window.MathJax = {     tex: {       inlineMath: [['$', '$'], ['\\(', '\\)']],         displayMath: [['$$', '$$'], ['\\[', '\\]']]       }   };    1.进程的描述：PCB、状态2....</div></div></div></a></div></div><!-- 添加 Valine 评论系统的 HTML 容器--><!-- Valine 评论系统--><div id="vcomments"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/126209991?v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">SEER</div><div class="author-info-description">Record SEER's learning content.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SEER666"><i class="fab fa-github"></i><span>关注我</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">我的博客已全面升级</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B9%B6%E5%8F%91%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">1.并发进程的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BD%8E%E7%BA%A7%E9%80%9A%E4%BF%A1"><span class="toc-number">2.</span> <span class="toc-text">2.进程之间的低级通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%92%E6%96%A5"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 进程之间的互斥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 进程之间的同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8CP%E3%80%81V%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 信号量和P、V操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AE%A1%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">3.管程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%AB%98%E7%BA%A7%E9%80%9A%E4%BF%A1"><span class="toc-number">4.</span> <span class="toc-text">4.进程的高级通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%B6%88%E6%81%AF%E7%BC%93%E5%86%B2%E9%80%9A%E4%BF%A1"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 消息缓冲通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%AD%BB%E9%94%81"><span class="toc-number">5.</span> <span class="toc-text">5.死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%AD%BB%E9%94%81%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 死锁的定义和产生的必要条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-%E6%AD%BB%E9%94%81%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1 死锁的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.1.2.</span> <span class="toc-text">5.1.2 死锁产生的必要条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">5.1.3.</span> <span class="toc-text">5.1.3 死锁产生的原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 解决死锁的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E9%B8%B5%E9%B8%9F%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1 鸵鸟算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2 死锁的预防</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 死锁的避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 死锁的检测和恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">习题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/14/20241214/" title="第3章 进程之间的并发控制和死锁"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第3章 进程之间的并发控制和死锁"/></a><div class="content"><a class="title" href="/2024/12/14/20241214/" title="第3章 进程之间的并发控制和死锁">第3章 进程之间的并发控制和死锁</a><time datetime="2024-12-14T06:30:00.000Z" title="发表于 2024-12-14 14:30:00">2024-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/12/20241212/" title="第2章 进程管理"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第2章 进程管理"/></a><div class="content"><a class="title" href="/2024/12/12/20241212/" title="第2章 进程管理">第2章 进程管理</a><time datetime="2024-12-12T06:30:00.000Z" title="发表于 2024-12-12 14:30:00">2024-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/10/20241210/" title="第1章 操作系统概论"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第1章 操作系统概论"/></a><div class="content"><a class="title" href="/2024/12/10/20241210/" title="第1章 操作系统概论">第1章 操作系统概论</a><time datetime="2024-12-10T06:30:00.000Z" title="发表于 2024-12-10 14:30:00">2024-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/28/20241128/" title="DC Former代码框架思路解析"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DC Former代码框架思路解析"/></a><div class="content"><a class="title" href="/2024/11/28/20241128/" title="DC Former代码框架思路解析">DC Former代码框架思路解析</a><time datetime="2024-11-28T13:30:00.000Z" title="发表于 2024-11-28 21:30:00">2024-11-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/24/2024112401/" title="Transformer文档阅读"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Transformer文档阅读"/></a><div class="content"><a class="title" href="/2024/11/24/2024112401/" title="Transformer文档阅读">Transformer文档阅读</a><time datetime="2024-11-24T06:30:00.000Z" title="发表于 2024-11-24 14:30:00">2024-11-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By SEER</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.1.0"></script><script src="/js/main.js?v=5.1.0"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.3.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/click-show-text.min.js" data-mobile="true" data-text="我,太,想,进,步,了" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
  el: '#vcomments',  // 挂载评论的 HTML 元素
  appId: 'X7VMJZiKLlND8y3EXDtaqPI5-gzGzoHsz',  // LeanCloud 的 App ID
  appKey: 'zFn5LKNiWC2vPb3y0RsW1nMK',  // LeanCloud 的 App Key
  path: window.location.pathname,  // 使用文章的路径作为评论的唯一标识
  placeholder: '留下你的评论吧...'  // 输入框的占位文本
})</script></body></html>