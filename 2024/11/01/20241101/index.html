<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>解决异构联邦优化中的目标不一致问题-论文阅读 | SEER's Study</title><meta name="author" content="SEER"><meta name="copyright" content="SEER"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="window.MathJax &#x3D; {     tex: {       inlineMath: [[&#39;$&#39;, &#39;$&#39;], [&#39;\\(&#39;, &#39;\\)&#39;]],         displayMath: [[&#39;$$&#39;, &#39;$$&#39;], [&#39;\\[&#39;, &#39;\\]&#39;]]       }   };     Tackling the Objective Inconsistency Problem in He">
<meta property="og:type" content="article">
<meta property="og:title" content="解决异构联邦优化中的目标不一致问题-论文阅读">
<meta property="og:url" content="https://seer666.github.io/2024/11/01/20241101/index.html">
<meta property="og:site_name" content="SEER&#39;s Study">
<meta property="og:description" content="window.MathJax &#x3D; {     tex: {       inlineMath: [[&#39;$&#39;, &#39;$&#39;], [&#39;\\(&#39;, &#39;\\)&#39;]],         displayMath: [[&#39;$$&#39;, &#39;$$&#39;], [&#39;\\[&#39;, &#39;\\]&#39;]]       }   };     Tackling the Objective Inconsistency Problem in He">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2024-11-01T05:00:00.000Z">
<meta property="article:modified_time" content="2024-11-02T08:31:24.181Z">
<meta property="article:author" content="SEER">
<meta property="article:tag" content="论文">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="https://avatars.githubusercontent.com/u/126209991?v=4"><link rel="canonical" href="https://seer666.github.io/2024/11/01/20241101/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.1.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        if (name && globalFn[key][name]) return
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '解决异构联邦优化中的目标不一致问题-论文阅读',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-02 16:31:24'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><a href="https://github.com/SEER666" target="_blank"> <img src="https://avatars.githubusercontent.com/u/126209991?v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></a></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我们</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://avatars.githubusercontent.com/u/126209991?v=4" alt="Logo"><span class="site-name">SEER's Study</span></a><a class="nav-page-title" href="/"><span class="site-name">解决异构联邦优化中的目标不一致问题-论文阅读</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我们</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">解决异构联邦优化中的目标不一致问题-论文阅读</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-01T05:00:00.000Z" title="发表于 2024-11-01 13:00:00">2024-11-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-02T08:31:24.181Z" title="更新于 2024-11-02 16:31:24">2024-11-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],  
      displayMath: [['$$', '$$'], ['\\[', '\\]']]  
    }
  };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


<h1 id="Tackling-the-Objective-Inconsistency-Problem-in-Heterogeneous-Federated-Optimization（解决异构联邦优化中的目标不一致问题）"><a href="#Tackling-the-Objective-Inconsistency-Problem-in-Heterogeneous-Federated-Optimization（解决异构联邦优化中的目标不一致问题）" class="headerlink" title="Tackling the Objective Inconsistency Problem in Heterogeneous Federated Optimization（解决异构联邦优化中的目标不一致问题）"></a>Tackling the Objective Inconsistency Problem in Heterogeneous Federated Optimization（解决异构联邦优化中的目标不一致问题）</h1><h2 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1.摘要"></a>1.摘要</h2><p>在联邦学习中，客户端本地数据集和计算速度的异质性导致每个客户端在每次通信轮次中执行的本地更新次数存在较大差异。对这些模型进行简单的加权聚合会导致目标不一致，即全局模型收敛到一个与真实目标函数相差任意大的不匹配目标函数的稳定点。本文提供了一个通用框架来分析异构联邦优化算法的收敛性。该框架涵盖了之前提出的方法，如FedAvg和FedProx，并提供了对解偏倚和由于目标不一致导致的收敛减慢的第一个原则性理解。利用这一分析的见解，我们提出了FedNova，这是一种归一化平均方法，它消除了目标不一致性，同时保持了快速误差收敛。</p>
<h2 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2.介绍"></a>2.介绍</h2><p>联邦学习是分布式优化的一个新兴子领域，在该领域中，数据收集和模型训练被推送到大量具有有限通信和计算能力的边缘客户端。与传统分布式优化不同，传统分布式优化在每次本地梯度计算后通过中央服务器或对等通信进行一致性操作，在联邦学习中，每个通信轮次中选择的客户端子集会在这些模型聚合以更新全局模型之前执行多次本地更新。<br>联邦学习中本地更新次数的异质性。参与联邦学习的客户端通常在本地数据集的大小和计算速度方面表现出高度异质性。联邦学习的原始论文提出，每个客户端执行 $E$ 个周期（遍历其本地数据集）的本地更新随机梯度下降（SGD），每次使用的小批量大小为 $B$。因此，如果一个客户端有 $n$ 个本地数据样本，则本地第 $i$ 次 SGD 迭代次数为 $\tau &#x3D; \frac{E n}{B}$，这在不同客户端之间可能差异很大。本地 SGD 迭代次数的异质性因客户端计算速度的相对变化而加剧。在给定的时钟时间内，较快的客户端可以比较慢的客户端执行更多的本地更新。由于不可预测的滞后或由后台进程、断电、内存限制等因素引起的减速，客户端在不同的通信轮次中进行的本地更新次数也可能有所不同。最后，客户端可能使用不同的学习率和本地求解器（而不是普通的）。这些方法（如 proximal gradient 方法或自适应学习率调度）可能导致每个客户端的模型进度存在异质性。<br>局部更新中的异质性导致目标不一致。大多数分析联邦优化算法收敛性的最新工作 [8-37] 假设所有客户端的本地更新次数相同（即，对于所有客户端 $i$，$\tau &#x3D; \tau$）。这些工作表明，周期性地在本地训练的客户端模型之间达成一致可以达到全局目标函数 $F(x) &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{m} F_i(x) $ 的驻点，该函数是加权局部目标的和，权重由数据集大小 $n$ 决定。然而，当前没有任何分析对本地更新或联邦优化算法在实际情况下，当本地更新次数 $\tau$ 在不同客户端之间变化时的收敛性提供见解。事实上，正如我们在第 3 节中所展示的，异质性本地更新后标准的客户端模型平均化会导致收敛到一个驻点——不是原始目标函数 $F(x)$ 的驻点，而是一个不一致的目标函数 $F’(x)$，其与 $F(x)$ 的差异可能取决于 $\tau$ 的相对值。如果客户端 1 执行更多的本地更新，则更新后的 $x^{(t+1,0)}$ 会偏离真实的全局最小值 $x^*$，向局部最小值 $x^*_1$ 偏移。<br>广义分析框架的需求。一种朴素的方法来克服异质性是固定每个客户端在通信轮次中必须完成的本地更新次数 $\tau$，并让快速节点空闲等待慢速客户端完成其更新。这种方法将确保目标一致性（即代理目标 $F(x)$ 等于真实目标 $F(x)$），然而，等待最慢的客户端会显著增加总的训练时间。更复杂的方法，如 FedProx、VRLSGD和 SCAFFOLD，这些方法旨在处理非 IID 本地数据集，可以在一定程度上减少（而非消除）目标不一致性，但这些方法要么导致收敛速度变慢，要么需要额外的通信和内存。到目前为止，对于联邦学习中具有异质本地更新这一挑战性的设置，尚无严格理解目标不一致性和收敛速度。同时，如何最好地结合使用不同本地进度水平训练的模型也尚不清楚。<br>本文贡献。据我们所知，本工作首次提供了对解中偏差（由目标不一致引起）的基本理解，以及客户端本地进度异质性如何影响收敛速率。在第4节中，我们提出了一种通用的理论框架，该框架允许不同数量的本地更新和非IID本地数据集。<br>此外，还包括不同的本地求解器，如GD、SGD、带近端梯度的SGD、梯度跟踪、自适应学习率、动量等。它涵盖了现有的方法，如FedAvg和FedProx，并对它们的收敛行为提供了新的见解。在第5节中，我们提出了FedNova，这是一种在平均时正确加权本地模型的方法。它确保了目标一致性，同时保持快速的误差收敛，并且在第6节中显示其性能优于现有方法。FedNova可以与任何本地求解器和服务器优化器配合使用，因此与现有的方法是互补的。</p>
<h2 id="3-系统模型与前期工作"><a href="#3-系统模型与前期工作" class="headerlink" title="3.系统模型与前期工作"></a>3.系统模型与前期工作</h2><p>联邦异构优化设置。在联邦学习中，总共m个客户端旨在共同解决以下优化问题：<br>$$<br>[<br>\min_{x \in \mathbb{R}^d} \left[ F(x) :&#x3D; \sum_{i&#x3D;1}^m p_i F_i(x) \right]<br>]<br>$$<br>其中 $p &#x3D; \frac{n_i}{n}$ 表示相对样本大小，$F(x) &#x3D; \frac{1}{n_i} f(x; \xi)$ 是在第 $i$ 个客户端处的局部目标函数。这里，$f$ 是由学习模型定义的损失函数（通常假设为凸函数），$\xi$ 表示来自本地数据集的样本。在第 $t$ 次通信时，$D$ 轮中，每个客户端独立地从当前全局模型 ( x^{(t,0)} ) 开始运行 ( \tau ) 次本地求解器（例如，SGD）迭代，以优化其自身的局部目标。<br>在我们的理论框架中，我们将 ( \tau ) 视为一个可以随轮次变化的任意标量。实际上，如果客户端运行相同的本地周期数 ( E )，则有:<br>$$<br>[<br>\tau &#x3D; \frac{E n}{B}<br>]<br>$$<br>其中 ( B ) 是小批量大小。或者，如果每个通信轮次在时钟时间上具有固定长度，则 ( \tau ) 表示客户端 ( i ) 在时间窗口内完成的本地迭代次数，并且可能在不同客户端之间（取决于它们的计算速度和可用性）以及不同的通信轮次之间发生变化。</p>
<p><strong>FedAvg基准算法</strong>联邦平均（FedAvg）是第一个也是最常用的算法，在每个通信轮次结束时用于在中央服务器上聚合这些本地训练的模型。共享全局模型的更新方式如下：<br>$$<br>x^{(t+1,0)} - x^{(t,0)} &#x3D; \sum_{i&#x3D;1}^m p_i \Delta_i^{(t)} &#x3D; -\sum_{i&#x3D;1}^m p_i \cdot \eta \sum_{k&#x3D;0}^{r_i - 1} g_i(x_i^{(t,k)})<br>\tag{2}<br>$$<br>其中，$x_i^{(t,k)}$ 表示在第 $t$ 次通信轮次中第 $k$ 次本地更新后的客户端 $i$ 的模型，$\Delta_i^{(t)} &#x3D; x_i^{(t,r_i)} - x_i^{(t,0)}$ 表示客户端 $i$ 在第 $t$ 轮次中累计的本地进展。此外，$\eta$ 是客户端的学习率，$g_i$ 表示一个包含 $B$ 个样本的小批量的随机梯度。<br>当客户端数量 $m$ 较大时，中央服务器可能在每一轮中仅随机选择部分客户端进行计算。 </p>
<p><strong>FedProx</strong>通过添加一个近端项来改进 FedAvg。为了缓解由于非独立同分布数据和异构本地更新导致的一致性问题，提出在每个本地目标中添加一个近端项：<br>$$<br>[<br>\mu \left| x^{(t,0)} - x^{(t,i)} \right|^2<br>]<br>$$<br>其中 $( \mu )$ 是一个可调参数。这个近端项将每个本地模型向后拉得更接近全局模型 $( x^{(t,0)} )$。尽管研究表明 FedProx 改进了 FedAvg，但其收敛性分析受限于比之前的 FedAvg 分析更强的假设，并且仅适用于足够大的 $( \mu )$。<br>由于 FedProx 是我们一般框架的一个特例，我们的收敛性分析提供了对 $( \mu ) $影响的敏锐见解。我们表明，较大的 $( \mu ) $可以减轻（但不能消除）目标不一致性，尽管这会以较慢的收敛速度为代价。我们提出的 FedNova 方法可以通过保证一致性而不减慢收敛速度来改进 FedProx。<br>通过动量和跨客户端方差减少改进FedAvg。近期文献中通过在服务器端应用动量或使用跨客户端方差减少技术如VRLSGD和SCAFFOLD来提升FedAvg的性能。再次强调，这些工作没有考虑异构本地进度。我们提出的归一化平均方法FedNova与这些加速或方差减少技术正交，并且可以轻松结合。此外，FedNova也与梯度压缩&#x2F;量化和公平聚合技术兼容并互补。</p>
<h2 id="4-异构联邦优化的新理论框架"><a href="#4-异构联邦优化的新理论框架" class="headerlink" title="4.异构联邦优化的新理论框架"></a>4.异构联邦优化的新理论框架</h2><p>我们现在提出一个通用的理论框架，该框架涵盖了多种联邦优化算法，并有助于分析目标不一致性对其误差收敛的影响。虽然结果是针对全客户端参与设置提出的，但很容易将其扩展到每轮随机采样一部分客户端的情况。</p>
<h3 id="4-1-异构联邦优化的广义更新规则"><a href="#4-1-异构联邦优化的广义更新规则" class="headerlink" title="4.1 异构联邦优化的广义更新规则"></a>4.1 异构联邦优化的广义更新规则</h3><p>根据（2）中的回顾，联邦优化算法的更新规则可以表示为 $ x(t+1,0) - x(t,0) &#x3D; \sum <em>{i&#x3D;1}^{m} p_i \Delta(it)$，其中$\Delta(it) :&#x3D; x(t,\tau <em>i) - x(t,0)$表示第 $(i)$ 个客户端在第 $(t) $轮的局部参数变化，(p_i &#x3D; \frac{n_i}{n}) 是客户端 (i) 的数据比例。我们将其更新规则重写为更一般的形式如下：<br>$$<br>[<br>x^{(t+1, 0)} - x^{(t, 0)} &#x3D; -\tau</em>{\text{eff}} \sum</em>{i&#x3D;1}^{m} w_i \cdot \eta d_i^{(t)} ]<br>$$<br>以下三个更新规则的关键元素在不同算法中表现出不同的形式：<br><strong>局部平均梯度 $d(t)$：</strong>不失一般性，我们可以将累积的局部变化重写为<br>$$<br>\Delta(t) &#x3D; \eta G(t)a<br>$$<br>其中<br>$$<br>G(t) &#x3D; [ \text{sgn}(c x h(a, s, t)), g g(a, d x i(e, n, t)), \text{sgn}(t h(e, r, \tau u, n)) ]<br>$$<br>是一个非负向量，并定义了随机梯度如何在局部累积。然后，通过归一化梯度权重 $a$，局部平均梯度定义为<br>$$<br>d(t) &#x3D; \frac{G(t)a}{| a |_1}<br>$$<br>归一化因子 $| a |<em>1$ 是向量 $a$ 的 $(l_1)$ 范数。通过设置不同的 $a$，(4) 式适用于大多数常见的客户端优化器，如带有近端更新的 SGD、局部动量和可变学习率，更广泛地说，适用于任何累积变化<br>$$<br>\Delta(t) &#x3D; \eta G(t)a<br>$$<br>即局部梯度的线性组合的求解器。<br>具体来说，如果客户端优化器是普通的 SGD（即 FedAvg 的情况），那么<br>$$<br>a &#x3D; [1, 1, …, 1] \in \mathbb{R}^{\tau_i}<br>$$<br>新框架与 FedAvg 在规范化梯度方面的比较。因此，规范化梯度只是当前模型参数空间内所有随机梯度的简单平均值。实心黑色圆圈表示<br>$$<br>d(t) &#x3D; \frac{G(t)a_i}{\tau_i} &#x3D; \frac{\sum</em>{k&#x3D;-01}^{g_i(x(t,k))}}{\tau_i}<br>$$<br>稍后，在本节中，我们将展示更多关于如何通过新的通用更新规则和 FedAvg 进行更新的具体示例。</p>
<p><strong>聚合权重 $(w_i)$：</strong>每个客户端的局部平均梯度 (d_i) 在计算聚合梯度<br>$$<br>\sum_{i&#x3D;1}^{m} w_i d_i<br>$$<br>时乘以权重 (w_i)。根据定义，这些权重满足<br>$$<br>\sum_{i&#x3D;1}^{m} w_i &#x3D; 1<br>$$<br>请注意，这些权重决定了全局目标<br>$$<br>F(x) &#x3D; \sum_{i&#x3D;1}^{m} w_i F_i(x)<br>$$<br>的逼近方向，FedAvg 隐式地为本地步数更多的客户端分配更高的权重，导致全局方向偏移——我们将在定理 1 中正式证明这一点。</p>
<p><strong>有效步数 $(\tau)$：</strong>由于客户端 $(i)$ 执行了 $(\tau_i) $次本地更新，每次通信轮次的平均本地 SGD 步数为<br>$$<br>\bar{\tau} &#x3D; \frac{\sum_{i&#x3D;1}^{m} \tau_i}{m}<br>$$<br>然而，服务器可以通过设置参数 (\tau) 大于或小于 (\bar{\tau}) 来调整聚合更新的影响（类似于选择全局学习率 [25, 40]）。我们称比值<br>$$<br>\frac{\bar{\tau}}{\tau}<br>$$<br>为减速比，并且它在第 4.2 节的收敛性分析中起着重要作用。</p>
<p>规则（4）使我们能够为给定的局部求解器 $(a)$ 自由选择 $(\tau)$ 和$ (w)$，这有助于设计如 FedNova 等快速且一致的算法，FedNova 是第 5 节中提出的一种归一化平均方法。在图 3 中，我们进一步说明了上述关键元素如何影响算法，并在模型参数空间中比较了新的广义更新规则和 FedAvg。<br>此外，在实现方面，服务器不需要知道局部累积向量 (a) 的具体形式。每个客户端可以将归一化的更新$\eta d(t)$发送到中央服务器，这只是累积局部变化 $\Delta(t)$的一个重新缩放版本。这种重新缩放确保了服务器能够有效地执行聚合，而不必深入了解每个客户端的具体更新机制。这种设计不仅提升了算法的灵活性，还增强了其适应不同类型客户端优化器的能力，使得在分布式学习环境中能够更好地处理异构数据和计算能力差异。<br>通过这种方式，FedNova 可以在一定程度上减轻因客户端间的非独立同分布（non-IID）数据引起的训练不均匀性，从而提高全局模型的收敛速度和准确性。我们在后续部分将详细探讨 FedNova 的具体实现与性能评估，及其在实际应用中的优势。<br>$$<br>x^{(t+1,0)} - x^{(t,0)} &#x3D; \sum_{i&#x3D;1}^{m} p_i \Delta_i^{(t)} &#x3D; - \sum_{i&#x3D;1}^{m} p_i |a_i|_1 \cdot \frac{\eta G_i^{(t)} a_i}{|a_i|<em>1}<br>$$<br>$$<br>&#x3D; -\left(\sum</em>{i&#x3D;1}^{m} p_i |a_i|<em>1 \right) \eta \sum</em>{i&#x3D;1}^{m} \left( \frac{p_i |a_i|<em>1}{\sum</em>{i&#x3D;1}^{m} p_i |a_i|<em>1} \cdot \frac{G_i^{(t)} a_i}{|a_i|<em>1} \right).<br>$$<br>$$<br>\tau</em>{\text{eff}} : \text{effective local steps} \hspace{20pt} w_i : \text{weight} \hspace{20pt} d_i : \text{normalized gradient}<br>$$<br>不同于更一般的公式（4），公式（6）概括了以下先前的方法。在公式（6）中，(\tau) 和 (w</em>{\text{eff}, i}) 由局部求解器的选择（即 (a) 的选择）隐式固定。这意味着在特定的情况下，我们可以通过简单调整局部更新的步数和相应的权重来实现对全局模型更新的有效控制。<br>由于空间限制，以下示例的推导被移到了附录。</p>
<p><strong>香草SGD作为本地求解器（FedAvg）</strong>：在FedAvg中，本地求解器是SGD，使得$a_i &#x3D;[1, 1, \ldots, 1] \in \mathbb{R}^{\tau_i} \text{ 并且 } |a_i|<em>1 &#x3D; \tau_i$。因此，局部平均梯度$d_i$是$\tau_i$次迭代的简单平均值，$\tau</em>{\text{eff}} &#x3D; \frac{\sum_{i&#x3D;1}^n p_i \tau_i}{\sum_{i&#x3D;1}^n p_i \tau_i}$。<br>并且$w_i &#x3D; p_i \tau_i &#x2F; \sum_{i&#x3D;1}^n p_i \tau_i$。也就是说，具有更多本地步骤的标准化梯度将隐式地分配更高的权重。<br><strong>近端SGD作为本地求解器（FedProx）</strong>在FedProx中，本地SGD步骤通过近端项校正。可以证明<br>$$<br>a_i &#x3D; [(1 - \alpha) \tau_i^{-1}, (1 - \alpha) \tau_i^{-2}, \ldots, (1 - \alpha), 1] \in \mathbb{R}^{\tau_i},<br>$$<br>其中$\alpha &#x3D; \eta \mu$，并且$\mu$是一个可调参数。在这种情况下，我们有$|a_i|<em>1 &#x3D; [1 - (1 - \alpha)^{\tau_i} ] &#x2F; \alpha $<br>因此，$\tau</em>{\text{eff}} &#x3D; \alpha^{-1} \sum_{i&#x3D;1}^n p_i [1 - (1 - \alpha)^{\tau_i}]$，并且$w_i &#x3D; p_i [1 - (1 - \alpha)^{\tau_i}] &#x2F; \sum_{i&#x3D;1}^n p_i [1 - (1 - \alpha)^{\tau_i}]$。<br>当$\alpha &#x3D; 0$时，FedProx等价于FedAvg。随着$\alpha &#x3D; \eta \mu$增加，FedProx中的$w_i$。更类似于$p_i$，从而使代理目标$\tilde{F}(x)$更加一致。然而，更大的$\alpha$对应于较小的$\tau_{\text{eff}}$，从而减慢收敛速度，正如我们在下一小节中讨论的那样。<br><strong>带衰减学习率的SGD作为本地求解器</strong>假设客户的本地学习率呈指数衰减，则我们有$a_i &#x3D; [1, \gamma_i, \ldots, \gamma_i^{\tau_i^{-1}}]$。其中$\gamma_i \ge 0$可以在客户间变化。因此我们有$|a_i|_1 &#x3D; (1 - \gamma_i^{\tau_i}) &#x2F; (1 - \gamma) \text{ 和 }  w_i \approx p_i (1 - \gamma_i^{\tau_i}) &#x2F; (1 - \gamma_i)$。与FedProx (7)的情况相比，改变$\gamma_i$的值有类似于改变$(1 - \alpha)$。<br><strong>动量SGD作为本地求解器</strong>如果我们使用动量SGD，其中本地动量缓冲区在每轮开始时被重置为零 [25]，由于跨装置FL [2]的无状态特性，则我们有$a_i &#x3D; [1 - \rho^{\tau_i}, 1 - \rho^{\tau_i - 1}, \ldots, 1 - \rho] &#x2F; (1 - \rho)$，其中$\rho$是动量因子，并且$|a_i|_1 &#x3D; [\tau_i - \rho(1 - \rho^{\tau_i})] &#x2F; (1 - \rho)] &#x2F; (1 - \rho)$。更一般地，新公式（6）表明${w_i \ne p_i }$当客户具有不同的$|\alpha_i|_1$<br>时，这可能是由于不平衡本地更新（i.e., 客户有不同的维度），或各种本地学习率&#x2F;动量时间表（i.e., 客户具有不同的时间尺度）。</p>
<h2 id="4-2-光滑非凸函数的收敛性分析"><a href="#4-2-光滑非凸函数的收敛性分析" class="headerlink" title="4.2 光滑非凸函数的收敛性分析"></a>4.2 光滑非凸函数的收敛性分析</h2><p>在下面的定理1和定理2中，我们对一般更新规则（4）进行了收敛性分析，并量化了由于目标不一致导致的解偏差。该分析依赖于SGD标准分析中使用的假设1和假设2，以及联邦优化文献中常用的前提假设3，用以捕捉局部目标的差异。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://SEER666.github.io">SEER</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://seer666.github.io/2024/11/01/20241101/">https://seer666.github.io/2024/11/01/20241101/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://SEER666.github.io" target="_blank">SEER's Study</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BA%E6%96%87/">论文</a></div><div class="post-share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/11/05/20241106/" title="20241105-CSAPP课本阅读"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">20241105-CSAPP课本阅读</div></div><div class="info-2"><div class="info-item-1">   window.MathJax = {     tex: {       inlineMath: [['$', '$'], ['\\(', '\\)']],         displayMath: [['$$', '$$'], ['\\[', '\\]']]       }   };     第2章 信息的表示和处理2.3 整数运算2.3.1 无符号加法对于参数x和y的相关运算，操作 $+_w^u$ 描述为： 原理：无符号数加法 对满足 $0 \le x, \ y &lt; 2^w$ 的 $x$ 和 $y$ 有： $$x +_w^u y &#x3D;\begin{cases}x + y, &amp; x + y &lt; 2^w \quad \text{正常} \x + y - 2^w, &amp; 2^w \le x + y &lt; 2^{w+1} \quad \text{溢出}\end{cases}\tag{2.11}$$ 此外，判定是否发生的溢出的原理如下：原理：检测无符号数加法中的溢出对在范围 $0 \le x, \ y \le UMax_w$ 中的 $x$ 和...</div></div></div></a><a class="pagination-related" href="/2024/10/31/202401031/" title="Fedprox在隐私保护方面的考虑"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Fedprox在隐私保护方面的考虑</div></div><div class="info-2"><div class="info-item-1">   window.MathJax = {     tex: {       inlineMath: [['$', '$'], ['\\(', '\\)']],         displayMath: [['$$', '$$'], ['\\[', '\\]']]       }   };     Journal | [J] Electronics. Volume 12 , Issue 20 . 2023. PP 4364-  Consideration of FedProx in Privacy...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/10/14/2024.10.14/" title="2024.10.14."><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-14</div><div class="info-item-2">2024.10.14.</div></div><div class="info-2"><div class="info-item-1">今天的学习内容今天我继续阅读FIGRET-sigcomm2024-1(TE)V2。目前已经阅读至TE模型部分。 1.论文关键词流量工程，广域网，数据中心网络，机器学习 2.TE模型部分2.1 概念介绍网络拓扑（Network Topology）通过图𝐺建模的网络拓扑结构是整个流量工程优化的基础。节点表示交换机或路由器，链路表示节点之间的通信线路，链路的容量决定了流量能够通过的上限。 需求矩阵（Demand Matrix, DM）这是一个 ∣𝑉∣×∣𝑉∣的矩阵，用于表示网络中每一对源-目的节点之间的流量需求。需求矩阵帮助TE模型确定需要转发的流量规模，并为流量分配和路径选择提供依据。 最大链路利用率（MLU, Maximum Link Utilization）MLU 是优化目标中最关键的度量指标，表示网络中单条链路的最大利用率。最小化MLU可以避免网络链路的过载问题，提高网络的整体性能。 TE配置（TE...</div></div></div></a><a class="pagination-related" href="/2024/10/15/2024.10.15/" title="2024.10.15."><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-15</div><div class="info-item-2">2024.10.15.</div></div><div class="info-2"><div class="info-item-1">今天的学习内容今天我继续阅读FIGRET-sigcomm2024-1(TE)V2。目前已经阅读至FIGRET部分。 1.论文关键词流量工程，广域网，数据中心网络，机器学习 2.TE模型部分2.1 概念介绍最大链路利用率MLU...</div></div></div></a><a class="pagination-related" href="/2024/09/25/2024.9.25/" title="2024.9.25."><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-25</div><div class="info-item-2">2024.9.25.</div></div><div class="info-2"><div class="info-item-1">今天的学习内容今天我继续阅读FIGRET-sigcomm2024-1(TE)V2。目前已经阅读至介绍部分。 1.论文关键词流量工程，广域网，数据中心网络，机器学习 2.介绍部分2.1 原文重现随着网络流量的指数级增长，数据中心网络和广域网（WAN）越来越依赖流量工程（TE）来优化网络性能。TE 通常通过软件定义网络（SDN）的集中控制器实现，定期解决优化问题，以有效地将流量分配到网络路径上，然后将这些解决方案转化为路由器配置。 TE 中的一个主要挑战是管理突发流量。由于中央控制器在收集流量需求、计算新的 TE 解决方案以及更新转发规则时引入的延迟，TE 系统通常需要在实际流量到达之前，基于历史数据预先计算网络配置。然而，实际网络流量本质上的动态性和不可预测性给预测带来了巨大的困难。如果对流量突发准备不足，可能导致严重的网络拥塞，引发延迟增加、数据包丢失率上升以及网络吞吐量下降。因此，增强应对意外流量突发的鲁棒性至关重要。 现有的基于流量突发的 TE...</div></div></div></a><a class="pagination-related" href="/2024/10/31/202401031/" title="Fedprox在隐私保护方面的考虑"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-31</div><div class="info-item-2">Fedprox在隐私保护方面的考虑</div></div><div class="info-2"><div class="info-item-1">   window.MathJax = {     tex: {       inlineMath: [['$', '$'], ['\\(', '\\)']],         displayMath: [['$$', '$$'], ['\\[', '\\]']]       }   };     Journal | [J] Electronics. Volume 12 , Issue 20 . 2023. PP 4364-  Consideration of FedProx in Privacy...</div></div></div></a><a class="pagination-related" href="/2024/10/27/20241027/" title="20241027论文学习"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-27</div><div class="info-item-2">20241027论文学习</div></div><div class="info-2"><div class="info-item-1">Communication-Efficient and Private Federated Learning with Adaptive Sparsity-Based Pruning on Edge...</div></div></div></a><a class="pagination-related" href="/2024/10/30/20241030/" title="基于异构数据多隐私机制的局部差分隐私联邦学习-论文阅读"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-30</div><div class="info-item-2">基于异构数据多隐私机制的局部差分隐私联邦学习-论文阅读</div></div><div class="info-2"><div class="info-item-1">   window.MathJax = {     tex: {       inlineMath: [['$', '$'], ['\\(', '\\)']],         displayMath: [['$$', '$$'], ['\\[', '\\]']]       }   };     Local differential privacy federated learning based on heterogeneous data multi-privacy...</div></div></div></a></div></div><!-- 添加 Valine 评论系统的 HTML 容器--><!-- Valine 评论系统--><div id="vcomments"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/126209991?v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">SEER</div><div class="author-info-description">Record SEER's learning content.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SEER666"><i class="fab fa-github"></i><span>关注我</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">我的博客已全面升级</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Tackling-the-Objective-Inconsistency-Problem-in-Heterogeneous-Federated-Optimization%EF%BC%88%E8%A7%A3%E5%86%B3%E5%BC%82%E6%9E%84%E8%81%94%E9%82%A6%E4%BC%98%E5%8C%96%E4%B8%AD%E7%9A%84%E7%9B%AE%E6%A0%87%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">Tackling the Objective Inconsistency Problem in Heterogeneous Federated Optimization（解决异构联邦优化中的目标不一致问题）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%91%98%E8%A6%81"><span class="toc-number">1.1.</span> <span class="toc-text">1.摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">2.介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%89%8D%E6%9C%9F%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.3.</span> <span class="toc-text">3.系统模型与前期工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BC%82%E6%9E%84%E8%81%94%E9%82%A6%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B0%E7%90%86%E8%AE%BA%E6%A1%86%E6%9E%B6"><span class="toc-number">1.4.</span> <span class="toc-text">4.异构联邦优化的新理论框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%BC%82%E6%9E%84%E8%81%94%E9%82%A6%E4%BC%98%E5%8C%96%E7%9A%84%E5%B9%BF%E4%B9%89%E6%9B%B4%E6%96%B0%E8%A7%84%E5%88%99"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 异构联邦优化的广义更新规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%85%89%E6%BB%91%E9%9D%9E%E5%87%B8%E5%87%BD%E6%95%B0%E7%9A%84%E6%94%B6%E6%95%9B%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">1.5.</span> <span class="toc-text">4.2 光滑非凸函数的收敛性分析</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/24/20241124/" title="改进具有动态可组合多头注意力的Transformer"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="改进具有动态可组合多头注意力的Transformer"/></a><div class="content"><a class="title" href="/2024/11/24/20241124/" title="改进具有动态可组合多头注意力的Transformer">改进具有动态可组合多头注意力的Transformer</a><time datetime="2024-11-24T03:20:00.000Z" title="发表于 2024-11-24 11:20:00">2024-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/23/20241123/" title="改进具有动态可组合多头注意力的Transformer"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="改进具有动态可组合多头注意力的Transformer"/></a><div class="content"><a class="title" href="/2024/11/23/20241123/" title="改进具有动态可组合多头注意力的Transformer">改进具有动态可组合多头注意力的Transformer</a><time datetime="2024-11-23T15:00:00.000Z" title="发表于 2024-11-23 23:00:00">2024-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/22/2024112202/" title="改进具有动态可组合多头注意力的Transformer"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="改进具有动态可组合多头注意力的Transformer"/></a><div class="content"><a class="title" href="/2024/11/22/2024112202/" title="改进具有动态可组合多头注意力的Transformer">改进具有动态可组合多头注意力的Transformer</a><time datetime="2024-11-22T07:00:00.000Z" title="发表于 2024-11-22 15:00:00">2024-11-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/22/2024112201/" title="改进具有动态可组合多头注意力的Transformer"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="改进具有动态可组合多头注意力的Transformer"/></a><div class="content"><a class="title" href="/2024/11/22/2024112201/" title="改进具有动态可组合多头注意力的Transformer">改进具有动态可组合多头注意力的Transformer</a><time datetime="2024-11-22T04:00:00.000Z" title="发表于 2024-11-22 12:00:00">2024-11-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/05/20241105/" title="20241105-CSAPP课本阅读"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="20241105-CSAPP课本阅读"/></a><div class="content"><a class="title" href="/2024/11/05/20241105/" title="20241105-CSAPP课本阅读">20241105-CSAPP课本阅读</a><time datetime="2024-11-05T11:00:00.000Z" title="发表于 2024-11-05 19:00:00">2024-11-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By SEER</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.1.0"></script><script src="/js/main.js?v=5.1.0"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (false) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.3.0/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/click-show-text.min.js" data-mobile="true" data-text="我,太,想,进,步,了" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script>new Valine({
  el: '#vcomments',  // 挂载评论的 HTML 元素
  appId: 'X7VMJZiKLlND8y3EXDtaqPI5-gzGzoHsz',  // LeanCloud 的 App ID
  appKey: 'zFn5LKNiWC2vPb3y0RsW1nMK',  // LeanCloud 的 App Key
  path: window.location.pathname,  // 使用文章的路径作为评论的唯一标识
  placeholder: '留下你的评论吧...'  // 输入框的占位文本
})</script></body></html>